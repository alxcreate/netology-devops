# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

> 1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.

    chdir("/tmp")
---
>
> 2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:

    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64

> Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

    vagrant@vagrant:~$ strace file
в выводе есть строка с указанием файла

    openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

---
>
> 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

Запускаем процесс:

    vagrant@vagrant:~$ ping localhost -c 10000 >> fileping
Определяем pid процесса:

    vagrant@vagrant:~$ ps ax | grep ping
    1757 pts/2    S+     0:00 ping localhost -c 10000
Определяем размер файла (2840):

    vagrant@vagrant:~$ sudo lsof -p 1757 | grep fileping
    ping    1757 vagrant    1w   REG  253,0     2840 1311526 /home/vagrant/fileping
Удаляем файл и проверяем размер открытого (9455):

    vagrant@vagrant:~$ rm fileping
    vagrant@vagrant:~$ sudo lsof -p 1757 | grep fileping
    ping    1757 vagrant    1w   REG  253,0     9455 1311526 /home/vagrant/fileping (deleted)
Вывод идет в stdout - 1:

    vagrant@vagrant:~$ sudo ls -lah /proc/1757/fd/
    total 0
    dr-x------ 2 root    root     0 Jul  4 12:01 .
    dr-xr-xr-x 9 vagrant vagrant  0 Jul  4 12:01 ..
    lrwx------ 1 root    root    64 Jul  4 12:01 0 -> /dev/pts/2
    l-wx------ 1 root    root    64 Jul  4 12:01 1 -> '/home/vagrant/fileping (deleted)'
    lrwx------ 1 root    root    64 Jul  4 12:01 2 -> /dev/pts/2
    lrwx------ 1 root    root    64 Jul  4 12:01 3 -> 'socket:[33895]'
    lrwx------ 1 root    root    64 Jul  4 12:01 4 -> 'socket:[33896]'
Обрезаем файл до 0:

    vagrant@vagrant:~$ sudo truncate -s 0 /proc/1757/fd/1
Проверяем размер новых данных (568):

    vagrant@vagrant:~$ sudo lsof -p 1757 | grep fileping
    ping    1757 vagrant    1w   REG  253,0      568 1311526 /home/vagrant/fileping (deleted)

---
>
> 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Процесс при завершении освобождает все свои ресурсы (кроме PID — идентификатора) и становится зомби — пустой записью в таблице процессов, хранящей код завершения для родительского процесса.

Система уведомляет родительский процесс о завершении дочернего с помощью сигнала SIGCHLD. Он считает код возврата с помощью системного вызова wait(), после чего запись зомби будет удалена из списка процессов.

Если родительский процесс игнорирует SIGCHLD (а он игнорируется по умолчанию), то зомби остаются до его завершения.

---
>
> 5. В iovisor BCC есть утилита `opensnoop`:

    bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc

> На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

    vagrant@vagrant:~$ sudo opensnoop-bpfcc
    PID    COMM               FD ERR PATH
    914    vminfo              5   0 /var/run/utmp
    637    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
    637    dbus-daemon        21   0 /usr/share/dbus-1/system-services
    637    dbus-daemon        -1   2 /lib/dbus-1/system-services
    637    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/
    387    systemd-udevd      14   0 /sys/fs/cgroup/unified/system.slice/systemd-

---
>
> 6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

Выполняется системный вызов uname()

    Part of the utsname information is also accessible via
    /proc/sys/kernel/{ostype, hostname, osrelease, version,
    domainname}.

---
>
> 7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:

    bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#

> Есть ли смысл использовать в bash `&&`, если применить `set -e`?

При использовании && вторая команда строки будет выполнена при успешном завершении первой (возврате кода 0), иначе выполнение будет прервано.

Символ ; используется для разделения команд в одной строке с последовательным выполнением.

set -e используется длязавершения оболочки при сбое команды.

Использование $$ в сочетании с set -e нецелесообразно потому как обе команды прерывают выполнение если возникнет ошибка выполнения.

---
>
> 8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

Указанные опции в команде:

* -e — остановка выполнения если команда дает ненулевой статус выхода;
* -u — при попытке обращения к неопределенным переменным, выдает сообщение об ошибке и прерывает работу сценария;
* -x — вывод команд во время выполнения;
* -o — используется если нужно убедиться, что все команды в пайпах завершились успешно

---
>
> 9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

Часто встречаемое состояние процессов в обычной системе - R, I, S.

* I — idle
* D — процесс в непрерывном сне (usually IO)
* R — процесс либо запущен, либо ожидает в очереди;
* S — процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса
* T — процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ)
* X — мертвый процесс
* Z — зомби-процесс. Дочерний процесс выполнение которого завершилось.

* < — высокий приоритет
* N — низкий приоритет
* L — has pages locked into memory (for real-time and custom IO)
* s — is a session leader
* l — is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
* \+ — is in the foreground process group.
